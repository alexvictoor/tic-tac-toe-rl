{"version":3,"sources":["engine/game.ts","engine/agent.ts","engine/engine.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Game","currentPlayer","board","lastPlay","this","hasWon","bind","clone","filter","c","length","player","boardIndex","mark","getPlayerMark","whereToPlay","includes","Error","gameAfterPlay","getCurrentPlayer","map","play","cell","index","getWinner","drawnGame","lines","some","line","every","find","p","join","raw","game","split","QAgent","alpha","explorationFactor","formerState","qualities","getQuality","undefined","isOver","learn","action","chooseAction","currentGame","formerGame","formerAction","qualityOfFormerGame","toString","qualityOfCurrentGame","reward","computeReward","updatedQualityOfFormerGame","winner","gameAndAction","outcomes","getPossibleOutcomes","winningPlay","actionIndex","gamePrefix","bestActions","String","sort","t1","t2","Math","random","floor","train","firstAgent","secondAgent","agents","initialGame","gamesToReplay","start","Date","chooseExplorationFactor","i","nbGameWithoutReplay","chooseInitialGame","pop","startNewGame","turnIndex","agent","push","console","log","getTime","Square","props","className","onClick","value","Board","squares","renderSquare","React","Component","GameComponent","state","history","Array","fill","stepNumber","trainingDone","player2Agent","triggerPlayer2Agent","setTimeout","setState","slice","player1Turn","newGame","updateGameState","cb","concat","step","status","current","moves","move","desc","key","jumpTo","handleClick","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b20fdc32.chunk.js","sourcesContent":["\nexport type Player = 'Player1' | 'Player2';\ntype Cell = '.' | 'x' | 'o';\ntype Board = [ \n    Cell, Cell, Cell,\n    Cell, Cell, Cell,\n    Cell, Cell, Cell\n];\n\nexport type ChangeCallback = (update: Game) => void \n\nexport class Game {\n\n    currentPlayer: Player = 'Player1';\n    board: Board = ['.','.','.','.','.','.','.','.','.'];\n\n    lastPlay: number = -1;\n\n    constructor() {\n        this.hasWon = this.hasWon.bind(this);\n    }\n\n    static fromString(raw: String) {\n        const game = new Game();\n        game.board = raw.split(' ').join('').split('') as any;\n        game.currentPlayer = game.getCurrentPlayer();\n        return game;\n    }\n    \n    private clone() {\n        const clone = new Game();\n        clone.currentPlayer = this.currentPlayer;\n        clone.board = [...this.board] as Board;\n        return clone;\n    }\n\n    private getCurrentPlayer() {\n        const nbX = this.board.filter(c => c === 'x').length;\n        const nbO = this.board.filter(c => c === 'o').length;\n        return nbX > nbO ? 'Player2' : 'Player1';\n    }\n\n    private getPlayerMark(player: Player) {\n       return player === 'Player1' ? 'x' : 'o'; \n    }\n\n    play(boardIndex: number) {\n        const mark: Cell = this.getPlayerMark(this.currentPlayer);\n        if (!this.whereToPlay().includes(boardIndex)) {\n            throw new Error('Not a valid play');\n        }\n        const gameAfterPlay = this.clone();\n        gameAfterPlay.board[boardIndex] = mark;\n        gameAfterPlay.currentPlayer = gameAfterPlay.getCurrentPlayer();\n        gameAfterPlay.lastPlay = boardIndex;\n        return gameAfterPlay;\n    }\n\n    getPossibleOutcomes(): [number, Game][]  {\n        return this.whereToPlay()\n                    .map(boardIndex => [boardIndex, this.play(boardIndex)]);\n    }\n\n    whereToPlay(): number[] {\n        return this.board\n                .map((cell, index) => [cell, index])\n                .filter(([cell, _]) => cell === '.')\n                .map(([_, index]) => index) as number[]; // wtf typescript\n    }\n\n    drawnGame(): boolean {\n        return this.whereToPlay().length === 0; \n    }\n\n    isOver(): boolean {\n        return !!this.getWinner() || this.drawnGame();\n    }\n\n    private static lines = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8],\n        [0, 3, 6],\n        [1, 4, 7],\n        [2, 5, 8],\n        [0, 4, 8],\n        [2, 4, 6],\n    ];\n\n    private hasWon(player: Player) {\n        const mark = this.getPlayerMark(player);\n        return Game.lines.some(line => (\n            line.every(cell => (\n                this.board[cell] === mark\n            )\n        )));\n    }\n\n    getWinner() {\n        return ['Player1', 'Player2'].find(p => this.hasWon(p as Player));\n    }\n\n    toString() {\n        return this.board.join('');\n    }\n}\n","import { Game, Player } from './game';\n\nexport type Agent = {\n    play: (game: Game) => Game ,\n    startNewGame: () => void,\n};\n\ntype Policy = (game: Game) => number;\n\nexport const DummyAgent = (game: Game) => {\n    const indices = game.whereToPlay();\n    if (indices.length === 0) {\n        //Game is already over\n        return game;\n    }\n    return game.play(indices[0]); \n} \n\ntype GameAndAction = [Game, number];\n\nexport class QAgent implements Agent {\n    formerState?: GameAndAction;\n    qualities: {[gameAndAction: string]: number};\n\n    constructor(private player: Player, private alpha: number, public explorationFactor: number) {\n        this.getQuality = this.getQuality.bind(this);\n        this.play = this.play.bind(this);\n        this.qualities = {};\n    }\n\n    startNewGame() {\n        this.formerState = undefined;\n        //console.log(\"start new\", Object.entries(this.qualities).filter(([key, value]) => (key.startsWith('.........'))));\n    }\n\n    play(game: Game): Game {\n        if (game.isOver()) {\n            if (!this.formerState) {\n                // should not happen except during experience replay\n            } else {\n                this.learn(this.formerState, game, -1);\n            }\n            return game;\n        }\n        const action = this.chooseAction(game);\n        if (this.formerState) {\n            this.learn(this.formerState, game, action);\n        }\n        this.formerState = [game, action];\n        return game.play(action);\n    }\n\n    learn([formerGame, formerAction]: GameAndAction, currentGame: Game, action: number) {\n        const qualityOfFormerGame = this.getQuality(formerGame.toString() + formerAction);\n        const qualityOfCurrentGame = this.getQuality(currentGame.toString() + action);\n        const reward = this.computeReward(currentGame); \n\n        const updatedQualityOfFormerGame = \n            qualityOfFormerGame + this.alpha * (reward + qualityOfCurrentGame - qualityOfFormerGame);\n\n       // Q =  Q + ( R + Q' - Q ) / 2\n       // 2Q = 2Q + R + Q' - Q\n       // Q = Q' + R\n       // Q' = Q - R\n\n       // avec 0.3\n       // Q =  Q + ( R + Q' - Q ) / 3\n       // 3Q = 3Q  \n\n\n        this.qualities[formerGame.toString() + formerAction] = updatedQualityOfFormerGame;\n    }\n\n    private computeReward(currentGame: Game) {\n        const winner = currentGame.getWinner();\n        if (winner) {\n            if (winner === this.player) {\n                return 100;\n            } \n            return -100;\n        }\n        if (currentGame.drawnGame()) {\n            return 10;\n        }\n        return 0;\n    }\n\n    private getQuality(gameAndAction: string) {\n        return this.qualities[gameAndAction] || 0;\n    }\n\n    chooseAction(game: Game): number {\n        const outcomes = game.getPossibleOutcomes();\n        const winningPlay = outcomes.find(([_, game]) => game.getWinner() === this.player);\n        if (winningPlay) {\n            const [actionIndex, _] = winningPlay;\n            return actionIndex;\n        }\n        const gamePrefix = game.toString();\n        const bestActions: number[] = (\n            outcomes\n                .map(([actionIndex, _]) => ([actionIndex, gamePrefix + String(actionIndex)]))\n                .map(([actionIndex, gameAndAction]) => ([actionIndex, this.getQuality(gameAndAction as string)]))\n                .sort((t1, t2) => ((t2[1] as number) - (t1[1] as number)))\n                .map(([actionIndex, _]) => actionIndex as number)\n        );\n        const explore = Math.random() < this.explorationFactor;\n        if (explore) {\n            const randomIndex = Math.floor(Math.random() * bestActions.length);\n            return bestActions[randomIndex]; \n        }\n        return bestActions[0];\n    }\n}\n","import { QAgent } from \"./agent\";\nimport { Game } from \"./game\";\n\nexport const train = (firstAgent: QAgent, secondAgent: QAgent) => {\n    let agents = [firstAgent.play, secondAgent.play];\n    const initialGame = new Game();\n    const gamesToReplay: Game[] = [ initialGame ];\n    const nbGameWithoutReplay = 20000;\n    const start = new Date();\n\n    const chooseExplorationFactor = (i: number) => {\n      if (i < nbGameWithoutReplay/5) {\n        return 0.6;\n      }\n      if (i < nbGameWithoutReplay/3) {\n        return 0.4;\n      }\n      if (i < nbGameWithoutReplay/2) {\n        return 0.2;\n      }\n      return 0;\n    }\n\n    const chooseInitialGame = (i: number) => (\n      ((i > nbGameWithoutReplay-1 ) && gamesToReplay.pop()) || initialGame\n    );\n\n    let i = 0;\n    while (i < nbGameWithoutReplay || gamesToReplay.length > 0) {\n      i++;\n      firstAgent.startNewGame();\n      secondAgent.startNewGame();\n      \n      // explore a lot at the beginning\n      // less after\n      const explorationFactor = chooseExplorationFactor(i);\n      firstAgent.explorationFactor = explorationFactor;\n      secondAgent.explorationFactor = explorationFactor;\n\n      // initial game can be an empty board\n      // or a replayed experience\n      let game = chooseInitialGame(i);\n      \n      let turnIndex = 0;\n      while (!game.isOver()) {\n          const agent = agents[turnIndex % 2];\n\n          // save random games for experience replay\n          if (turnIndex > 0 && Math.random() > 0.66 && i < nbGameWithoutReplay) {\n            gamesToReplay.push(game);\n          }\n\n          game = agent(game);\n          turnIndex++;\n      }      \n      \n      // learn to loose\n      const agent = agents[turnIndex % 2];\n      game = agent(game);\n\n      //console.log(\"The winner is\", game.getWinner(), i, gamesToReplay.length); \n    }\n\n    firstAgent.explorationFactor = 0;\n    secondAgent.explorationFactor = 0;\n    //console.log({ firstAgent, secondAgent });\n    console.log(`Training took ${new Date().getTime() - start.getTime()}ms`);\n    console.log('Games played', i);\n}","import React from 'react';\nimport './App.css';\nimport { Game } from './engine/game';\nimport { DummyAgent, QAgent } from './engine/agent';\nimport { train } from './engine/engine';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      \n      <GameComponent/>\n    </div>\n  );\n}\n\nfunction Square(props: any) {\n  return (\n    <button className=\"square\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nclass Board extends React.Component<any> {\n  renderSquare(i: number) {\n    return (\n      <Square\n        value={this.props.squares[i]}\n        onClick={() => this.props.onClick(i)}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row\">\n          {this.renderSquare(0)}\n          {this.renderSquare(1)}\n          {this.renderSquare(2)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(3)}\n          {this.renderSquare(4)}\n          {this.renderSquare(5)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(6)}\n          {this.renderSquare(7)}\n          {this.renderSquare(8)}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass GameComponent extends React.Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    const firstAgent = new QAgent('Player1', 0.3, 0.2);\n    const secondAgent = new QAgent('Player2', 0.3, 0.2);\n    const initialGame = new Game();\n    this.state = {\n      history: [\n        {\n          squares: Array(9).fill(null),\n          game: initialGame,\n        }\n      ],\n      stepNumber: 0,\n      trainingDone: false,\n      player2Agent: secondAgent.play,\n    };\n    this.triggerPlayer2Agent = this.triggerPlayer2Agent.bind(this);\n    setTimeout(() => {\n      train(firstAgent, secondAgent);\n      this.setState({ trainingDone: true})\n    });\n  }\n\n  handleClick(i: number) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const game: Game = current.game;\n    const player1Turn = game.currentPlayer === \"Player1\";\n    if (game.isOver() || !game.whereToPlay().includes(i) || !player1Turn) {\n      return;\n    }\n    const newGame = game.play(i);\n    this.updateGameState(player1Turn, i, newGame, this.triggerPlayer2Agent);\n  }\n\n  triggerPlayer2Agent(currentGame: Game) {\n    const newGame: Game = this.state.player2Agent(currentGame);\n    if (!currentGame.isOver()) {\n      this.updateGameState(false, newGame.lastPlay, newGame);\n    }\n  }\n\n  updateGameState(player1Turn: boolean, i: number, newGame: Game, cb?: (newGame: Game) => void) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice();\n    squares[i] = player1Turn ? \"X\" : \"O\";\n    this.setState({\n      history: history.concat([\n        {\n          game: newGame,\n          squares,\n        }\n      ]),\n      stepNumber: history.length,\n    }, cb && (() => { cb(newGame); }));\n  }\n\n  jumpTo(step: number) {\n    this.setState({\n      stepNumber: step,\n    });\n  }\n\n  render() {\n\n    if (!this.state.trainingDone) {\n      return (<div>Machine is learning how to play...<br/>This might take a few seconds</div>);\n    }\n\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n    const game: Game = current.game;\n    const winner = game.getWinner();\n\n    const moves = history.map((step: any, move: any) => {\n      const desc = move ?\n        'Go to move #' + move :\n        'Go to game start';\n      return (\n        <li key={move}>\n          <button onClick={() => this.jumpTo(move)}>{desc}</button>\n        </li>\n      );\n    });\n    \n\n    let status;\n    if (winner) {\n      status = \"Winner: \" + winner;\n    } else {\n      status = \"Next player: \" + game.currentPlayer;\n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board\n            squares={current.squares}\n            onClick={(i: any) => this.handleClick(i)}\n          />\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <ol>{moves}</ol>\n        </div>\n      </div>\n    );\n  }\n}\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { train } from './engine/engine';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n//train(10000);\n"],"sourceRoot":""}